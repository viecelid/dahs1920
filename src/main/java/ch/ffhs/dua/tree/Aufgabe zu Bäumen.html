<html>
<meta charset="UTF-8"> 
<body>

<h1>Aufgaben zu Bäumen</h4>
<h3>Aufgabe 1</h3>
<p>Analog zu den Traversierungen in 6.2.4 aus [SG] implementiere man 
rekursiv eine Traversierung für beliebige (nicht nur binäre) Bäume.</p>
<p>Implementiere Sie dazu eine Klasse DepthFirstTraverser</p>
<pre>package ch.ffhs.dua;
public abstract class DepthfirstTraverser&lt;N&gt; {
    public void traverse(TreeNode&lt;N&gt; node) { ... }<br>    public abstract  void preOperation(N value) { }   
    public abstract void postOperation(N value) { }   
}
</pre>
<p>In konkreten Subklassen sollte mindestens eine der beiden Methoden 
preOperation oder postOperation überschrieben sein. Für jeden Knoten k 
wird einmal preOperation(k.value()) und einmal postOrder(k.value()) 
aufgerufen, und zwar preOperation(k.value()) bevor die Kinder von k 
durchlaufen werden, und postOperation(k.value()) nachdem die Kinder von k
 durchlaufen worden sind.</p>
<p>(Falls nur die Methode preOperation überschrieben wird, so entspricht
 das der Preorder-Traversierung bei Binärbäumen, falls nur postOperation
 überschrieben wird, so entspricht das der Postorder-Traversierung bei 
Binärbäumen.)</p>

<h3>Aufgabe 2</h3>
<p>Analog zu Aufgabe 1 implementiere man einen Traverser für beliebige 
(nicht nur binäre) Bäume, jedoch ohne Rekursion zu verwenden. Der 
Einfacheit halber können Sie sich hier Pre-Order-Traversierung 
beschränken:</p>
<p>Implementiere Sie dazu eine Klasse DepthFirstPreOrderTraverser.</p>

<h3>Aufgabe 3</h3>
<p>Zu einem Baum erzeuge man einen Traverser als Iterator, der das Interface <code>Iterator&lt;N&gt;</code>
 implementiere. Dieser Iterator liefere die Knotenwerte in einer 
Pre-Order zurück. (Die remove Methode des Iterators soll eine 
UnsupportedOperationException werfen.)</p>
<p>(Hinweis: Sie können von Code des Traversers ohne Rekursion benutzen 
und anpassen. (Die rekursive Version kann ebenfalls verwendet werden, 
das ist aber komplizierter, da man die Rekursion unterbrechen muss; das 
könnte man machen, indem man die Rekursion in einem eigenen Thread 
laufen lässt und das Erzeuger-Verbraucher Muster verwendet).)</p>
<pre>package ch.ffhs.dua;
public abstract class DepthfirstTraverser&lt;N&gt; {
    public void traverse(TreeNode&lt;N&gt; node) { ... }<br>    public abstract void preOperation(N value) { }   
    public void traverse(TreeNode&lt;N&gt;) {
        ...
    }   
}
</pre>
<h3>Aufgabe 4</h3>
<p>Die bis jetzt unterssuchten Traverser verfolgen eine depth-first 
Strategie. Ein Baum kann jedoch auch mit der Breitensuche (oder 
Level-Suche) traversiert werden. Bei der Breitensuche wird zuersz die 
Wurzel besucht, dann alle Knoten mit Tiefe 1 (die Kinder der Wurzel), 
dann die Knoten mit Tiefe 2 (Enkelknoten der Wurzel) usw.</p>

<p>Implementieren Sie einen Traverser, der die Knoten eines Baumes mit Breitensuche traversiert.</p>
<p>(Hinweis: In Analogie zur Tiefensuche muss hier nicht ein Stack, sondern eine Queue verwendet werden mit zu besuchenden Knoten.</p>
<ul>
<li>Dieser Queue wird zu Beginn die Wurzel des Baumes hinzugefügt.</li>
<li>Folgende Schritte werden wiederholt, bis die Queue leer ist:</li>
<ul>
<li>Der erste Knoten k der Queue wird entfernt und besucht.</li>
<li>Alle Kinder von k werden der Queue am Ende hinzugefügt.)</li>
</ul>
</ul>
<p>Verwenden Sie dazu die Klassenrümpfe in diesem Package.</p>
</body>
</html>